from ninja import Router, Query, Schema
from ninja.pagination import paginate, PageNumberPagination
from typing import List
from vulnerability_analysis.schemas.metrics import (
    AppInfoRequest,
    AppInfoResponse,
    NetworkConnectionRequest,
    NetworkConnectionResponse,
    IODeviceRequest,
    IODeviceResponse,
    ProcessInfoRequest,
    ProcessInfoResponse,
    ProcessHeartbeatRequest,
    ProcessLogRequest,
    ActiveUserRequest,
    ActiveUserResponse,
)

from vulnerability_analysis.schemas import (
    AppInfoSchema,
    AppInfoFilterSchema,
    NetworkConnectionSchema,
    NetworkConnectionFilterSchema,
    IODeviceSchema,
    IODeviceFilterSchema,
    ProcessInfoSchema,
    ProcessInfoFilterSchema,
    ActiveUserSchema,
    ActiveUserFilterSchema,
)
from vulnerability_analysis.models import (
    AppInfo,
    NetworkConnection,
    IODevice,
    ProcessInfo,
    ProcessHeartbeat,
    ProcessLog,
    ActiveUser,
)
from vulnerability_analysis.schemas import (
    MessageResponse,
    ErrorResponse,
    CreateResponse,
    CreateResponsePayload,
)
import logging
from vulnerability_analysis.helpers import is_same_device, openapi_extra
from authentication.decorators import require_device_token, require_roles
from authentication.models import RoleType
logger = logging.getLogger(__name__)

router = Router()




def insert_app_info(app_info: AppInfoSchema)->AppInfo:
    try:
        existing_app_info = AppInfo.objects.get(device_name=app_info.device_name, apk_path=app_info.apk_path)
        for attr, value in app_info.dict(exclude_unset=True).items():
            setattr(existing_app_info, attr, value)
        existing_app_info.save()
        return existing_app_info
    except AppInfo.DoesNotExist:
        app_info = AppInfo.objects.create(**app_info.dict())
        return app_info
    

@router.post("/app-info", response={200: CreateResponse, 400: ErrorResponse}, auth=None, openapi_extra=openapi_extra)
@require_device_token()
def create_app_info(request, app_info: AppInfoRequest):
    if not is_same_device(request, app_info.device_id):
        return 404, ErrorResponse(error="Device not found")
    device_name = request.device_info.get("device_name")
    response:list[CreateResponsePayload] = []
    for app in app_info.apps:
        try:
            app.device_name = device_name
            new_app = insert_app_info(app)  
            response.append(CreateResponsePayload(model=AppInfoSchema.from_orm(new_app).model_dump(), success=True, error=None))
        except Exception as e:
            logger.error(f"Error inserting app info: {e}", exc_info=True)
            response.append(CreateResponsePayload(model=app.model_dump(), success=False, error=str(e)))
    return 200, CreateResponse(payload=response)


@router.get("/app-info", response={200: List[AppInfoResponse], 400: ErrorResponse}, openapi_extra=openapi_extra)
@paginate(PageNumberPagination)
@require_device_token()
@require_roles([RoleType.ADMIN])
def list_app_info(request, filters: AppInfoFilterSchema = Query(...)):
    try:
        device_name = request.device_info.get("device_name")
        apps = filters.filter(AppInfo.objects.filter(device_name=device_name))
        return apps
    except Exception as e:
        logger.error(f"Error listing app info: {e}", exc_info=True)
        return 400, ErrorResponse(error=str(e))
    

def insert_network_connection(connection: NetworkConnectionSchema)->NetworkConnection:
    try:
        existing_connection = NetworkConnection.objects.get(
            device_name=connection.device_name, 
            local_address=connection.local_address, 
            foreign_address=connection.foreign_address, 
            process_id=connection.process_id,
            program_name=connection.program_name, 
        )
        for attr, value in connection.dict(exclude_unset=True).items():
            setattr(existing_connection, attr, value)
        existing_connection.save()
        return existing_connection
    except NetworkConnection.DoesNotExist:
        new_connection = NetworkConnection.objects.create(**connection.dict())
        return new_connection

    
@router.post("/network-connection", response={200: CreateResponse, 400: ErrorResponse}, auth=None, openapi_extra=openapi_extra)
@require_device_token()
def create_network_connection(request, connection: NetworkConnectionRequest):
    if not is_same_device(request, connection.device_id):
        return 404, ErrorResponse(error="Device not found")
    device_name = request.device_info.get("device_name")
    response:list[CreateResponsePayload] = []
    for conn in connection.network_connections:
        try:
            conn.device_name = device_name
            new_connection = insert_network_connection(conn)
            response.append(CreateResponsePayload(model=NetworkConnectionSchema.from_orm(new_connection).model_dump(), success=True, error=None))
        except Exception as e:
            logger.error(f"Error inserting network connection: {e}", exc_info=True)
            response.append(CreateResponsePayload(model=conn.model_dump(), success=False, error=str(e)))
    return 200, CreateResponse(payload=response)


@router.get("/network-connection", response={200: List[NetworkConnectionResponse], 400: ErrorResponse}, openapi_extra=openapi_extra)
@paginate(PageNumberPagination)
@require_device_token()
@require_roles([RoleType.ADMIN])
def list_network_connections(request, filters: NetworkConnectionFilterSchema = Query(...)):
    try:
        device_name = request.device_info.get("device_name")
        connections = filters.filter(NetworkConnection.objects.filter(device_name=device_name))
        return connections
    except Exception as e:
        logger.error(f"Error listing network connections: {e}", exc_info=True)
        return 400, ErrorResponse(error=str(e))


def insert_io_device(device: IODeviceSchema)->IODevice:
    try:
        existing_device = IODevice.objects.get(device_name=device.device_name, device_path=device.device_path, device_type=device.device_type)
        for attr, value in device.dict(exclude_unset=True).items():
            setattr(existing_device, attr, value)
        existing_device.save()
        return existing_device
    except IODevice.DoesNotExist:
        return IODevice.objects.create(**device.dict())

@router.post("/io-device", response={200: CreateResponse, 400: ErrorResponse}, auth=None, openapi_extra=openapi_extra)  
@require_device_token()
def create_io_device(request, device: IODeviceRequest):
    if not is_same_device(request, device.device_id):
        return 404, ErrorResponse(error="Device not found")
    device_name = request.device_info.get("device_name")
    response:list[CreateResponsePayload] = []
    for dev in device.devices:
        try:
            dev.device_name = device_name
            new_device = insert_io_device(dev)
            response.append(CreateResponsePayload(model=IODeviceSchema.from_orm(new_device).model_dump(), success=True, error=None))
        except Exception as e:
            logger.error(f"Error inserting IO device: {e}", exc_info=True)
            response.append(CreateResponsePayload(model=dev.model_dump(), success=False, error=str(e)))
    return 200, CreateResponse(payload=response)
    

@paginate
@router.get("/io-device", response={200: List[IODeviceResponse], 400: ErrorResponse}, openapi_extra=openapi_extra)
@require_device_token()
@require_roles([RoleType.ADMIN])
def list_io_devices(request, filters: IODeviceFilterSchema = Query(...)):
    try:
        device_name = request.device_info.get("device_name")
        devices = filters.filter(IODevice.objects.filter(device_name=device_name))
        return 200, [IODeviceResponse.from_orm(device) for device in devices]
    except Exception as e:
        logger.error(f"Error listing IO devices: {e}", exc_info=True)
        return 400, ErrorResponse(error=str(e))

def insert_process_info(process: ProcessInfoSchema)->ProcessInfo:

    try:
        existing_process = ProcessInfo.objects.get(device_name=process.device_name, process_id=process.process_id, process_name=process.process_name)
        for attr, value in process.dict(exclude_unset=True).items():
            setattr(existing_process, attr, value)
        existing_process.save()
        return existing_process
    except ProcessInfo.DoesNotExist:
        return ProcessInfo.objects.create(**process.dict())


@router.post("/process-info", response={200: CreateResponse, 400: ErrorResponse}, auth=None, openapi_extra=openapi_extra)
@require_device_token()
def create_process_info(request, process: ProcessInfoRequest):
    if not is_same_device(request, process.device_id):
        return 404, ErrorResponse(error="Device not found")
    device_name = request.device_info.get("device_name")
    response:list[CreateResponsePayload] = []
    for proc in process.processes:
        try:
            proc.device_name = device_name
            new_process = insert_process_info(proc)
            response.append(CreateResponsePayload(model=ProcessInfoSchema.from_orm(new_process).model_dump(), success=True, error=None))
        except Exception as e:
            logger.error(f"Error inserting process info: {e}", exc_info=True)
            response.append(CreateResponsePayload(model=proc.model_dump(), success=False, error=str(e)))
    return 200, CreateResponse(payload=response)
    

@paginate
@router.get("/process-info", response={200: List[ProcessInfoResponse], 400: ErrorResponse}, openapi_extra=openapi_extra)
@require_device_token()
@require_roles([RoleType.ADMIN])
def list_process_info(request, filters: ProcessInfoFilterSchema = Query(...)):
    try:
        device_name = request.device_info.get("device_name")
        processes = filters.filter(ProcessInfo.objects.filter(device_name=device_name))
        return 200, [ProcessInfoResponse.from_orm(process) for process in processes]
    except Exception as e:
        logger.error(f"Error listing process info: {e}", exc_info=True)
        return 400, ErrorResponse(error=str(e))


@router.post("/process-heartbeat", response={200: MessageResponse, 400: ErrorResponse}, auth=None, openapi_extra=openapi_extra)
@require_device_token()
def create_process_heartbeat(request, heartbeat: ProcessHeartbeatRequest):
    try:
        if not is_same_device(request, heartbeat.device_id):
            return 404, ErrorResponse(error="Device not found")
        device_name = request.device_info.get("device_name")

        heartbeats:list[ProcessHeartbeat] = []
        for hb in heartbeat.heartbeats:
            hb.device_name = device_name
            heartbeats.append(ProcessHeartbeat(**hb.dict()))
        result = ProcessHeartbeat.objects.bulk_create(heartbeats)
        return 200, MessageResponse(message=f"Process heartbeat created successfully for {len(result)} heartbeats")

    except Exception as e:
        logger.error(f"Error creating process heartbeat: {e}", exc_info=True)
        return 400, ErrorResponse(error=str(e))



@router.post("/process-log", response={200: MessageResponse, 400: ErrorResponse}, auth=None, openapi_extra=openapi_extra)
@require_device_token()
def create_process_log(request, log: ProcessLogRequest):
    try:
        device_name = request.device_info.get("device_name")
        for l in log.logs:
            l.device_name = device_name
        result = ProcessLog.objects.bulk_create(log.logs)
        return 200, MessageResponse(message=f"Process log created successfully for {len(result)} logs")
    except Exception as e:
        logger.error(f"Error creating process log: {e}", exc_info=True)
        return 400, ErrorResponse(error=str(e))

@paginate
@router.get("/active-user", response={200: List[ActiveUserResponse], 400: ErrorResponse}, openapi_extra=openapi_extra)
@require_device_token()
@require_roles([RoleType.ADMIN])
def list_active_users(request, filters: ActiveUserFilterSchema = Query(...)):
    try:
        device_name = request.device_info.get("device_name")
        users = filters.filter(ActiveUser.objects.filter(device_name=device_name))
        return 200, [ActiveUserResponse.from_orm(user) for user in users]
    except Exception as e:
        logger.error(f"Error listing active users: {e}", exc_info=True)
        return 400, ErrorResponse(error=str(e))


def insert_active_user(user: ActiveUserSchema)->ActiveUser:
    try:
        existing_user = ActiveUser.objects.get(device_name=user.device_name, user_name=user.user_name, user_id=user.user_id, user_type=user.user_type)
        for attr, value in user.dict(exclude_unset=True).items():
            setattr(existing_user, attr, value)
        existing_user.save()
        return existing_user
    except ActiveUser.DoesNotExist:
        return ActiveUser.objects.create(**user.dict())

@router.post("/active-user", response={200: CreateResponse, 400: ErrorResponse}, auth=None, openapi_extra=openapi_extra)
@require_device_token()
def create_active_user(request, user: ActiveUserRequest):
    device_name = request.device_info.get("device_name")
    response:list[CreateResponsePayload] = []
    for usr in user.users:
        try:
            usr.device_name = device_name
            new_user = insert_active_user(usr)
            response.append(CreateResponsePayload(model=ActiveUserSchema.from_orm(new_user).model_dump(), success=True, error=None))
        except Exception as e:
            logger.error(f"Error inserting active user: {e}", exc_info=True)
            response.append(CreateResponsePayload(model=usr.model_dump(), success=False, error=str(e)))
    return 200, CreateResponse(payload=response)